@page "/DisplayAllCategories/DisplayCategory/DisplaySegment/DisplayQuestions/{SubCategoryId:int}"
@rendermode InteractiveServer
@using ValhallaVault.Data.Repositories
@using ValhallaVault.Data.Models
@using ValhallaVault.Components.Pages.RazorComponents
@using Microsoft.Data.SqlClient
@using Microsoft.AspNetCore.Identity
@using ValhallaVault.Data
@using System.Reflection.Metadata.Ecma335
@inject SubcategoryRepo SubcategoryRepo
@inject QuestionRepo QuestionRepo
@inject AnswerRepo AnswerRepo
@inject UserQuestionRepo UserQuestionRepo
@inject AuthenticationStateProvider AuthStateProvider
@inject UserManager<ApplicationUser> UserManager


@if (SubcategoryId == null)
{
    <div class="container mt-4">
        <p class="alert alert-warning">Something went wrong! The Subcategory Id was null.</p>
    </div>
    return;
}

@if (Subcategory == null)
{
    <div class="container mt-4">
        <p class="alert alert-warning">Someting went wrong! The Subcategory was not found.</p>
    </div>
    return;
}

@if (Subcategory.Questions == null)
{
    <div class="container mt-4">
        <p class="alert alert-warning">Someting went wrong! The Questions could not be reterived.</p>
    </div>
    return;
}

@if (CurrentQuestion == null || CurrentQuestion.Answers == null)
{
    <div class="container mt-4">
        <p class="alert alert-warning">Someting went wrong! This Question or the questions answers could not be reterived.</p>
    </div>
    return;
}









<div class="container mt-4">
    <h1 class="text-primary">@Subcategory.Name</h1>
    <p class="text-muted">Total Questions: @(Subcategory.Questions.Count)</p>

    <div class="card">
        <div class="card-body">
            <h4 class="card-title mb-4">@CurrentQuestion.Question</h4>
            <ul class="list-group list-group-flush">
                @foreach (AnswerModel answer in CurrentQuestion.Answers)
                {
                    <li class="list-group-item" style="@(styleForAnswers[answer.Id])">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" @bind="answer.IsChecked" />
                            <label class="form-check-label">@answer.Answer</label>
                        </div>
                    </li>
                }
            </ul>
        </div>
        <div class="card-footer">
            <button @onclick="BackOneQuestion" class="btn btn-secondary" disabled="@_disableBackButton">Back</button>
            <button @onclick="CorrectAnswers" class="btn btn-primary" disabled="@(_disableCorrectTheAnswersButton || UserHasChosenAnswer() != true)">Correct Answer</button>
            <button @onclick="NextQuestion" class="btn btn-secondary" disabled="@_disableNextQuestionButton">Next</button>
        </div>
    </div>
</div>





@code {
    //ooo didnt know #region was a thing?? how have I not found out this before????!?!?

    #region Parameters

    [Parameter] 
    public int? SubcategoryId { get; set; }

    #endregion





    #region Variables

    private const string _styleForCorrectAnswer = "background-color:green;";
    private const string _styleForWrongAnswer = "background-color:red;";


    private SubcategoryModel? Subcategory;
    private List<QuestionModel> QuestionsForThisSubcategory; 
    private QuestionModel? CurrentQuestion;
    private Dictionary<int, string> styleForAnswers = new();
    private AnswerModel ChosenAnswer;
    private string? UserName;



    private bool _disableBackButton = true;
    private bool _disableCorrectTheAnswersButton = false;
    private bool _disableNextQuestionButton = false;

    #endregion


    #region EventHandlers


    private void BackOneQuestion(MouseEventArgs e)
    {
        throw new NotImplementedException();
    }
    private void CorrectAnswers(MouseEventArgs e)
    {

        if (UserHasChosenAnswer() != true) { return; }

        if (UserName == null)
        {
            //there is no logged in user
            return;
        }


        //sets the style for the answers
        //green background for the correct answer despite if the user has ticked in the wrong or right answer
        //red for a wrong answer that is ticked in
        CurrentQuestion?.Answers?.ForEach(a =>
        {
            //when the answer is correct
            if (a.IsCorrect == true)
            {
                if (!styleForAnswers.ContainsKey(a.Id)) return;
                styleForAnswers[a.Id] = _styleForCorrectAnswer;
                return;
            }

            //when the answer is wrong and ticked 
            if (a.IsChecked == true)
            {
                if (!styleForAnswers.ContainsKey(a.Id)) return;
                styleForAnswers[a.Id] = _styleForWrongAnswer;
                return;
            }


        });

        if (UserChoseCorrectAnswer())
        {
            SetAnswerOfQuestionInDb();
        }


    }
    private void NextQuestion(MouseEventArgs e)
    {
        throw new NotImplementedException();
    }


    #endregion


    #region Methods

    private bool BackButtonShouldBeDisabled()
    {
        return true;
    }
    private bool NextButtonShouldBeDisabled()
    {
        return true;
    }


    private void ClearStyleForAnswers()
    {
        foreach (var dictionaryIntString in styleForAnswers)
        {
            styleForAnswers[dictionaryIntString.Key] = "";
        }
    }


    private bool UserChoseCorrectAnswer()
    {
        if (UserHasChosenAnswer() != true) return false;

        bool answerIsCorrect = false;
        CurrentQuestion?.Answers?.ForEach(a =>
        {
            if (a.IsChecked == true && a.IsCorrect == true)
            {
                answerIsCorrect = true;
            }
        });
        return answerIsCorrect;
    }


    /// <summary>
    /// null when user has NOT chosen answer
    /// true when user has chosen ONE answer
    /// false when user has chosen MORE THAN ONE answer
    /// </summary>
    /// <returns>
    /// null when user has NOT chosen answer
    /// true when user has chosen ONE answer
    /// false when user has chosen MORE THAN ONE answer
    /// </returns>
    private bool? UserHasChosenAnswer()
    {
        int tickedAnswers = 0;

        CurrentQuestion?.Answers?.ForEach(a =>
        {
            if (a.IsChecked == true) tickedAnswers++;
        });


        return tickedAnswers switch
        {
            0 => null,        // user has not ticked any answer
            1 => true,        // user has ticked ONLY ONE answer
            _ => false    // user has ticked MORE THAN ONE
        };
    }


    /// <summary>
    /// This add a entry in the UserQuestions table in the db.
    /// Where all the information is stored about what user has answerd what question what correctly
    /// </summary>
    private void SetAnswerOfQuestionInDb()
    {
        if(CurrentQuestion == null)return;
        if(UserHasChosenAnswer() != true)return;


        string? userId = GetUserIdByNormalizedUserName().GetAwaiter().GetResult();
        if(userId == null )return;

        if (AnswerForQuestionForSpecificUserAlreadyExists(userId, CurrentQuestion.Id) == true)
        {

            //edit the entry
        }


        UserQuestionRepo.Add(new UserQuestionModel()
        {
            UserId = userId, 
            QuestionId = CurrentQuestion.Id,
            IsCorrect = UserChoseCorrectAnswer()
        });
        UserQuestionRepo.Save().GetAwaiter().GetResult();
    }

    /// <summary>
    /// Checks if the logged in user has already answerd this particular question
    /// </summary>
    /// <param name="userId"></param>
    /// <param name="questionId"></param>
    /// <returns></returns>
    private bool? AnswerForQuestionForSpecificUserAlreadyExists(string? userId, int? questionId)
    {
        if (userId == null || questionId == null) return null;
        int? count = UserQuestionRepo.GetAll()
            .Where(q => q.QuestionId == questionId)
            .Where(q => q.UserId == userId)
            .ToList().Count;
        if (count != 0)
        {
            return true;
        }

        return false;
    }

    private async Task<string?> GetUserIdByNormalizedUserName(string? userName)
    {
        if (userName == null) return null;
        userName = userName.Trim().ToUpper();
        ApplicationUser? user = UserManager.FindByNameAsync(userName).GetAwaiter().GetResult();
        string? userId = user?.Id;
        return userId;

    }
    private async Task<string?> GetUserIdByNormalizedUserName()
    {
        return await GetUserIdByNormalizedUserName(UserName);

    }

    
    #endregion
















    #region WhenFirstLoadingPage

    //----------When first loading in this page BELOW THIS----------
    protected override async Task OnInitializedAsync()
    {
        if (SubcategoryId == null) return;
        Subcategory = await SubcategoryRepo.GetById((int)SubcategoryId);

        if(Subcategory == null)return;



        UserName = (await AuthStateProvider.GetAuthenticationStateAsync())?.User?.Identity?.Name;

        await GetUserIdByNormalizedUserName(UserName);


        //TODO FIX THIS SHIT, THE DATA HANDLING/ SEARCHING / FILTERING SHOULD NOT HERE

        //horribly ineffective way to do this :/
        //but since no methods in repo does what I need...

        Subcategory.Questions = (await QuestionRepo.GetAllQuestions())
            .Where(q => q.SubcategoryId == SubcategoryId)
            .ToList();

        foreach (QuestionModel question in Subcategory.Questions)
        {
            int index = Subcategory.Questions.FindIndex(q => q.Id == question.Id);
            Subcategory.Questions[index].Answers = (await AnswerRepo.GetAllAnswers())
                .Where(a => a.QuestionId == question.Id)
                .ToList();
        }

        CurrentQuestion = Subcategory.Questions.FirstOrDefault();

        CurrentQuestion?.Answers?.ForEach(a =>
        {
            styleForAnswers.Add(a.Id, "");
        });
    }

    #endregion
    
}
